import "ModularFormLinearAlgebra.mag":
    TransformBasis;

debug := false;

// Tool used to provide debug message if debug = true;
debugLog := procedure(str)
    if debug then
        str;
    end if;
end procedure;


//This function takes in a matrix M : V -> W and a basis of V
//It returns a modified basis of V compatible with the smith normal form, as well as
//the order related to the basis element in a pair
SNFToOrdersAndBasis := function(M, basis) 
    S, P, Q := SmithForm(M);

    orderAndBasis := [];
    snfBasis := TransformBasis(Transpose(Q), basis);
    dim := Minimum([NumberOfColumns(S), NumberOfRows(S)]);
    for i in [1 .. dim] do
    order := Truncate(Rationals() ! S[i,i]);
        Append(~orderAndBasis, <order, snfBasis[i]>);
    end for;

    return orderAndBasis;
end function;

OrderAndBasisToGroupString := function(orderBasis : underlyingRing := "Z_3")
    str := "";
    for pair in orderBasis do
        order := pair[1];
        if order eq 0 then
            str := str cat " " cat underlyingRing cat " x";
        elif order ne 1 then
            str := str cat " " cat underlyingRing cat " / " cat Sprint(order) cat " " cat underlyingRing cat " x";
        end if;
    end for;
    
    return str[1 .. #str-2];
end function;


// This returns the pAdicValuation of a number n without calling pAdicRing(3) ! which loses precision.
function Val(n, p)
    if n eq 0 then
        return -1;
    end if;
    if Sprint(Parent(n)) eq "Rational Field" then
        return Val(Numerator(n),p) - Val(Denominator(n),p); 
    end if;
    val := 0;
    while (n mod p) eq 0 do
        n := Truncate(n/p);
        val := val + 1;
    end while;
    return val;
end function;