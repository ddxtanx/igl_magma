import "BasisCompute.mag":
    Ker,
    KernelMatrix,
    q2,
    q4,
    ComputeQ2Q4Basis, 
    Psi,
    get_Wq;

for i in [2 .. 50] do                       
    ip := 2*i; // Weight needs to be even                            
    ip_pad := pAdicRing(3) ! ip; // Cast this to be pAdic to use the Valuation func
    ip_val := Valuation(ip_pad); // Compute valuation of the weight
    mat := KernelMatrix(ip, Rationals()); // Compute the factors of the kernel
    ker := Ker(ip, pAdicRing(3));

    ker_val := [];
    for val in ker do
        if val ne 0 then // 0 will act weird, so we dont want to consider it
            ker_val := Append(ker_val, Valuation(val)); // Add the valuation of the factor to the new list
        end if;
    end for;
    // Now we get the maximum valuation of the nonzero kernel factors
    max_val := 0; 
    max_index := 0;
    ind := 0;
    for val in ker_val do
        if val gt max_val then
            max_val := val;
            max_index := ind;
        end if;
        ind := ind + 1;
    end for;
    if max_val gt (ip_val + 1) then // If the maximum valuation exceeds what is expected, log it.
        "There is a counterexample at weight: " cat IntegerToString(2*i);
        S, P, Q := SmithForm(mat);
        V := VectorSpace(Rationals(), #ker);
        HS := Hom(V,V);
        MF := BaseExtend(ModularForms(2,ip), Rationals());
        vec_list := [];
        for j in [1 .. #ker] do
            if j eq max_index then
                vec_list := Append(vec_list, 1);
            else
                vec_list := Append(vec_list, 0);
            end if;
        end for;
        vec := V ! vec_list;
        linmap := HS ! (Q);
        trans_vec := linmap(vec);
        trans_vec_list := Eltseq(trans_vec);
        basis := ComputeQ2Q4Basis(ip);
        form := MF ! 0;
        for j in [1 .. #ker] do
            form := form + basis[j] * trans_vec_list[j];
        end for;
        "With representative element: ";
        form;
        "And basis expression: ";
        trans_vec_list;
    end if;
end for;

w14base := [0, 1, 0, -1];
w14basis := ComputeQ2Q4Basis(14);
MF := BaseExtend(ModularForms(2, 14), Rationals());
f := MF ! 0;
for i in [1 .. #w14base] do
    f := f + w14base[i] * w14basis[i];
end for;

wq := get_Wq(MF, 2);
fh := Psi(f, wq);

fQ := qExpansion(f);
fhQ := qExpansion(fh);

ninef := 9*f;
ninefh := Psi(ninef, wq);

ninefQ := qExpansion(ninef);
ninefhQ := qExpansion(ninefh);

Q<q> := PowerSeriesRing(Rationals());

2^(14)*(Evaluate(fQ, q) - Evaluate(fQ, q^2) - Evaluate(fhQ, q^2)) + Evaluate(fhQ, q);
2^(14)*(Evaluate(ninefQ, q) - Evaluate(ninefQ, q^2) - Evaluate(ninefhQ, q^2)) + Evaluate(ninefhQ, q);