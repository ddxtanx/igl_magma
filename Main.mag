SetPath("/Applications/Magma/package/Geometry/ModFrm"); // To get access to operators.m
import "operators.m":
    get_Wq; // "Quick" computations of atkin lehner operators
            // It's actually slow af, if we can speed this up that would be
            // super great!
import "ModularFormLinearAlgebra.mag":
    BasisExpand,
    ChangeOfBasis,
    TransformBasis;

import "Helpers.mag":
    FactorMatrixCols,
    FactorMatrixRows,
    EnsureNoColDivByThree;

import "ModularForms.mag":
    Psi,
    ComputeC4C6Basis,
    ComputeQ2Q4Basis,
    q2,
    q4,
    Delta,
    c4,
    c6,
    IsModular,
    PsiDP1Inv;

import "Homology.mag":
    Ker,
    KernelMatrix,
    KernelSubBasis,
    InKer,
    Homology,
    ImageBasis;
c4tilde := PsiDP1Inv(c4);
c6tilde := PsiDP1Inv(c6);
str := "";
for weight in [4 .. 100 by 2] do
    wq := get_Wq(ModularForms(2, weight), 2);
    ker := Ker(weight, Rationals());
    are_modular := [InKer(f : wq := wq): f in ker];
    all_modular := true;
    for bool in are_modular do
        all_modular := all_modular and bool;
    end for;
    if not all_modular then
        "Not all forms at weight " cat IntegerToString(weight) cat " are modular";
    end if;
    dim := #ker;
    mod_dim := #Basis(ModularForms(1,weight));
    if dim ne mod_dim then
        "At weight " cat IntegerToString(weight) cat " dims are different!";
        "Kernel dimension: " cat IntegerToString(dim);
        "Modular Form Space Dim " cat IntegerToString(mod_dim);
    end if;
    str := str cat "," cat IntegerToString(dim);
    "Completed weight " cat IntegerToString(weight) cat ".";
end for;

 for i in [0 .. 1000] do                                             
     for j in [0 .. 10000] do                                             
         coef := 240*i-504*j;                                              
         weight := 4*i+6*j;                                                
         coefVal := Valuation(pAdicRing(3) ! coef);                        
            weightVal := Valuation(pAdicRing(3) ! weight);                    
         if weightVal + 1 gt coefVal then                                  
             "3 Div at " cat IntegerToString(i) cat "," cat IntegerToString(j);
             break;
         end if;                                                           
    end for;                                                          
end for;


str;
n := 500;
cijs := [];
nonzeros := [];
for j in [0 .. n] do
    subList := [];
    for i in [0 .. n] do

        c4Power := 1;
        c6Power := 1;
        if i gt 0 then
            c4Power := c4^i;
        end if;
        if j gt 0 then
            c6Power := c6^j;
        end if;
        if i eq 0 and j eq 0 then
            subList := Append(subList, 0);
            continue;
        end if;
        form := c4Power * c6Power;
        coefs := Coefficients(qExpansion(form));     
        coefs := [Integers() ! coef : coef in coefs];  
                                                                                                                                                        
        numCoefs := #coefs;      
        coefs := coefs[[2..numCoefs]]; 
        gcf := GCD(coefs);
        threeDivCoefs := Valuation(pAdicRing(3) ! gcf);
        expectedDiv := Valuation(pAdicRing(3) ! (4*i +6*j)) + 1;
        divDiff := expectedDiv - threeDivCoefs;
        if divDiff ne 0 then
            nonzeros := Append(nonzeros, [i,j,divDiff]);
        end if;
        subList := Append(subList, divDiff);
    end for;
    cijs := Append(cijs, subList);
end for;

badWeights := [];
for w in [270 .. (10*n-2) by 2] do
    if Valuation(pAdicRing(3) ! w) lt 3 then
        continue;
    end if;
    str := "Weight: " cat IntegerToString(w) cat "; Vals: ";
    forms := ComputeC4C6Basis(w);
    i := 0;
    for form in forms do
        coefs := [Integers() ! Coefficient(form, i) : i in [1 .. 20]];
        gcd := GCD(coefs);
        formVal := Valuation(pAdicRing(3) ! gcd);
        iVal := Valuation(pAdicRing(3) ! i) + 2;
        formVal - iVal;
        expectedVal := Valuation(pAdicRing(3) ! w) +1;
        valDiff := expectedVal-formVal;
        if valDiff gt 0 then
            badWeights := Append(badWeights, w);
        end if;
        char := "";
        if i gt 0 then
            char := ",";
        end if;
        str := str cat char cat IntegerToString(valDiff);
        i := i + 1;
    end for;
    str;
end for; 

str;
n := 500;
cijs := [];
nonzeros := [];
for j in [1 .. n] do
    subList := [];
    for i in [1 .. n] do
        // if (4*i + 6*j) mod 54 ne 0 then
        //     continue;
        // end if; 
        c4Power := 1;
        c6Power := 1;
        if i gt 0 then
            c4Power := c4^i;
        end if;
        if j gt 0 then
            c6Power := c6^j;
        end if;
        if i eq 0 and j eq 0 then
            subList := Append(subList, 0);
            continue;
        end if;
        form := c4Power * c6Power;
        coefs := Coefficients(qExpansion(form));     
        coefs := [Integers() ! coef : coef in coefs];  
                                                                                                                                                        
        numCoefs := #coefs;      
        coefs := coefs[[2..numCoefs]]; 
        gcf := GCD(coefs);
        threeDivCoefs := Valuation(pAdicRing(3) ! gcf);
        iDiv := Valuation(pAdicRing(3) ! i) + 2;
        expectedDiv := Valuation(pAdicRing(3) ! (4*i +6*j)) + 1;

        conjectureDiv := Minimum([iDiv, expectedDiv]);
        if threeDivCoefs ne conjectureDiv then
            "i = " cat IntegerToString(i) cat ", j = " cat IntegerToString(j);
            "Form div: " cat IntegerToString(threeDivCoefs) cat " conj Div: " cat IntegerToString(conjectureDiv);
        end if;
        
        divDiff := expectedDiv - threeDivCoefs;
        expectedDivDiff := Maximum([0, Valuation(pAdicRing(3) ! (4*i + 6*j)) - 1 - Valuation(pAdicRing(3) ! i)]); 
        if divDiff ne expectedDivDiff then
            "---";
            divDiff;
            expectedDivDiff; 
            "---";
        end if;
        if divDiff ne 0 then
            nonzeros := Append(nonzeros, [i,j,divDiff]);
        end if;
        subList := Append(subList, divDiff);
    end for;
    cijs := Append(cijs, subList);
end for;

for i in [2 .. 300] do
    modSpace := ModularForms(2, 2*i);                               
    eSeries := EisensteinSeries(modSpace);                                  
    eSeries := eSeries[#eSeries];                                            
    eSeries := (1/Coefficient(eSeries, 0)) * eSeries;                
    inv := PsiDP1Inv(eSeries);                                            
    vals := [Valuation( pAdicRing(3) ! (Denominator(Coefficient(inv, j)))) : j in [2 .. 50]];
    minV := Minimum(vals);                                                
    if minV ne 0 then                           
        "At " cat IntegerToString(i);
    else
        "None at " cat IntegerToString(i);
    end if;
end for;

for w in [4 .. 500 by 2] do
    b1 := Ker(w, Rationals());
    b2 := KernelSubBasis(w);

    cob := ChangeOfBasis(b1, b2);
    det := Determinant(cob);

    Valuation(pAdicRing(3) ! Denominator(det));
end for;


for w in [4 .. 500 by 2] do
    "Weight: " cat IntegerToString(w);
    space := ModularForms(2, w);
    wq := get_Wq(space, 2);
    b1 := Ker(w, Rationals() : wq := wq);
    psid_appl := [Psi(f : wq := wq) + f : f in b1];
    
    c4c6_basis := ComputeC4C6Basis(w);
    cob := ChangeOfBasis(c4c6_basis, psid_appl);
    psid_appl;
    "---";
    "COB Matrix from c4c6 to psid";
    cob;
    new_b1_modular := TransformBasis(cob, c4c6_basis);
    "Modular Basis";
    new_b1_modular;
    "Kernel Basis";
    new_b1 := [PsiDP1Inv(f: wq := wq) : f in new_b1_modular];
    new_b1;
    "---";
end for;


for w in [4 .. 500 by 2] do
    HMF02, HMF := Homology(w);

    orders1 := [pair[1] : pair in HMF02];
    orders2 := [pair[1] : pair in HMF];

    str1 := "";
    str2 := "";

    for order in orders1 do
        order_int := Truncate(order);
        if order_int eq 0 then
            str1 := str1 cat "Z_3 x ";
        elif order_int ne 1 then
            str1 := str1 cat "Z_3/ " cat IntegerToString(order_int) cat " Z_3 x ";
        end if;
    end for;

    if str1 eq "" then
        str1 := "{e}";
    else
        len1 := #str1;
        str1 := str1[1 .. len1-3];
    end if;

    str1 := "(" cat str1 cat ")";

    for order in orders2 do
        order_int := Truncate(order);
        if order_int eq 0 then
            str2 := str2 cat "Z_3 x ";
        elif order_int ne 1 then
            str2 := str2 cat "Z_3/ " cat IntegerToString(order_int) cat " Z_3 x ";
        end if;
    end for;

    if str2 eq "" then
        str2 := "{e}";
    else
        len2 := #str2;
        str2 := str2[1 .. len2-3];
    end if;

    str2 := "(" cat str2 cat ")";

    "Homology at weight " cat IntegerToString(w) cat ": " cat str1 cat " x " cat str2;
end for;