import "/Applications/Magma/package/Geometry/ModFrm/operators.m":
    get_Wq; // "Quick" computations of atkin lehner operators
            // It's actually slow af, if we can speed this up that would be
            // super great!

import "Helpers.mag":
    debugLog;

S2 := BaseExtend(ModularForms(2,2), Rationals());
E22 := S2.1;

S4 := BaseExtend(ModularForms(2,4), Rationals());
E4P := S4.1;
EI4 := S4.2;

q2 := 1/2 * E22;
q4 := 1/16*E4P - EI4;   

c4 := 16*(q2^2 - 3*q4);
c6 := 32*(9*q2*q4-2*q2^3);
Delta := q4^2 * (16*q2^2 - 64*q4);

// Computes psi(f) for a given modular form
// If the wq matrix is pre-computed, there is an
// optional option for it to be passed in
Psi := function(form : wq := -1) // Pass in wq for memoization
    if Type(form) ne ModFrmElt then
        return form;
    end if;
    debugLog("PSI: getting weight");
    weight := Weight(form); // Get the weight
    psi := Parent(form) ! 0;
    FS := BaseExtend(Parent(form), Rationals());
    if wq eq -1 then
        debugLog("PSI: getting wq");
        wq :=  get_Wq(FS, 2);
    end if;
    if (Sprint(BaseRing(form))) ne "Rational Field" then
        _, i1 := BaseExtend(Parent(form), Rationals());
        _, i2 := BaseExtend(FS, BaseRing(form));
        half_weight := Truncate(2^(weight/2)); // Prefactor is 2^(w/2)
        debugLog("PSI: computing psi");
        psi := half_weight * i2(i1(form) * wq); // Compute 2^(w/2) * AtkinLehner(form,2)
    else
        half_weight := Truncate(2^(weight/2));
        psi := half_weight * (form * wq);
    end if;
    return psi;
end function;

// The following computes a basis of forms generated by q2 and q4 for a given weight
// All basis elements will have leading coefficient 1 (possible since denominators are all powers of two)
// If including a precision different than 12, this WILL RETURN qEXPANSIONS NOT MODULAR FORMS
ComputeQ2Q4Basis := function(weight)
    basis := [];
    // Now we get q2 and q4 via the bases of the weight 2 and 4 modular form spaces
    S2 := BaseExtend(ModularForms(2,2), Rationals());
    E22 := S2.1;

    S4 := BaseExtend(ModularForms(2,4), Rationals());
    E4P := S4.1;
    EI4 := S4.2;

    q2 := 1/2 * E22;
    q4 := 1/16*E4P - EI4;   
    fourth := Truncate(weight/4); // q4's powers range from 0 to floor(weight / 4)
    half := Truncate(weight/2); // Computing q2's power requires access to 1/2
    twelfth := Truncate(weight/12);
    debugLog("COMPUTE: Beginning loop");
    for i in [0 .. half] do
            pre_factor := 1;
            fac_1 := 1;
            fac_2 := 1;
            remainder := weight - 2*i;

            if (remainder mod 4) ne 0 or remainder lt 0 then
                continue;
            end if;
            if i ne 0 then // We need these if statements because MAGMA is weird about f^0
                fac_1 := q2^i;
            end if;

            k := Truncate(remainder/4);
            if k ne 0 then
                fac_2 := q4^k;
            end if;
            debugLog("COMPUTE: Multiplying forms");
            form := fac_1 * fac_2;
            smallestCoef := LeadingCoefficient(qExpansion(form));
            formScaled := (1/smallestCoef) * form;
            basis := Append(basis, formScaled);
    end for;
    return basis;
end function;


ComputeC4C6Basis := function(weight)
    S2 := BaseExtend(ModularForms(2,2), Rationals());
    E22 := S2.1;

    S4 := BaseExtend(ModularForms(2,4), Rationals());
    E4P := S4.1;
    EI4 := S4.2;

    q2 := 1/2 * E22;
    q4 := 1/16*E4P - EI4;   

    c4 := 16*(q2^2 - 3*q4);
    c6 := 32*(9*q2*q4-2*q2^3);
    Delta := q4^2 * (16*q2^2 - 64*q4);
    basis := [];
    fourth := Truncate(weight/4); // q4's powers range from 0 to floor(weight / 4)
    sixth := Truncate(weight/2); // Computing q2's power requires access to 1/2
    debugLog("COMPUTE: Beginning loop");
    for i in [0 .. fourth] do
        for j in [0 .. sixth] do
            pre_factor := 1;
            fac_1 := 1;
            fac_2 := 1;
            fac_3 := 1;
            remainder := weight - 4*i - 6*j;

            if (remainder mod 12) ne 0 or remainder lt 0 then
                continue;
            end if;
            if i ne 0 then // We need these if statements because MAGMA is weird about f^0
                fac_1 := c4^i;
            end if;
            if j ne 0 then 
                fac_2 := c6^j;
            end if;

            k := Truncate(remainder/12);
            if k ne 0 then
                fac_3 := Delta^k;
            end if;
            debugLog("COMPUTE: Multiplying forms");
            form := fac_1 * fac_2 * fac_3;
            basis := Append(basis, form);
        end for;
    end for;
    return basis;
end function;

IsModular := function(f : wq := -1)
    weight := Weight(f);
    fh_almost := Psi(f : wq := wq); // No factor of 2^-weight cuz converting to rationals is annoying
    for i in [1 .. Precision(Parent(f))/2] do
        if 2^weight*Coefficient(f, i) ne Coefficient(fh_almost, 2*i) then
            return false;
        end if;
    end for;
    return true;
end function;

PsiDP1Inv := function(f : wq := -1)
    if Type(f) ne ModFrmElt then
        return f;
    else
        scale := 1/(2^(Weight(f))-1);           
        return scale * (Psi(f : wq := wq)-f);
    end if;
end function;

TwistMult := function(f,g : wq := -1)
    return PsiDP1Inv((Psi(f)+f)*(Psi(g)+g));
end function;

TwistMultPower := function(f, i : wq := -1)
    temp_f := f;
    for _ in [1 .. i-1] do
        temp_f := TwistMult(f, temp_f : wq := wq);
    end for;
    return temp_f;
end function;