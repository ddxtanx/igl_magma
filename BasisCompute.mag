SetPath("/Applications/Magma/package/Geometry/ModFrm"); // To get access to operators.m
import "operators.m":
    get_Wq; // "Quick" computations of atkin lehner operators
            // It's actually slow af, if we can speed this up that would be
            // super great!
debug := false;

// Logs debug output if debug mode is on
debugLog := procedure(str)
    if debug then
        str;
    end if;
end procedure;

// Factors the columns of the matrix w/o dividing by 3. 
// Used to make the Ker presentation of minimal complexity
FactorMatrixCols := function(mat)
    scale_list := [];
    threeAdics := pAdicRing(3);
    for i in [1 .. NumberOfColumns(mat)] do
        ithCol := ColumnSubmatrix(mat, i, 1);
        colElemList := Eltseq(ithCol);
        colElemList := [(Integers() ! v) : v in colElemList];
        gcd := Gcd(colElemList);
        val := Valuation(threeAdics ! gcd);
        if val gt 0 then
            "We have 3 torsion!";
        end if;
        gcd := gcd / (3^val);
        Append(~scale_list, 1/gcd);
    end for;
    scale_mat := DiagonalMatrix(Rationals(), scale_list);
    debugLog(mat);
    debugLog(mat*scale_mat);
    return mat * scale_mat;
end function;

// Factors the rows of a matrix w/o dividing by 3
// Used in making KernelMatrix of minimal complexity
FactorMatrixRows := function(mat)
    scale_list := [];
    threeAdics := pAdicRing(3);
    for i in [1 .. NumberOfRows(mat)] do
        ithCol := RowSubmatrix(mat, i, 1);
        colElemList := Eltseq(ithCol);
        colElemList := [(Integers() ! v) : v in colElemList];
        gcd := Gcd(colElemList);
        val := Valuation(threeAdics ! gcd);
        gcd := gcd / (3^val);
        Append(~scale_list, 1/gcd);
    end for;
    scale_mat := DiagonalMatrix(Rationals(), scale_list);
    debugLog(mat);
    debugLog(scale_mat*mat);
    return scale_mat*mat;
end function;

EnsureNoColDivByThree := function(matrix)
    scale_list := [];
    threeAdics := pAdicRing(3);
    for i in [1 .. NumberOfColumns(matrix)] do 
        ithCol := ColumnSubmatrix(matrix, i, 1);
        colElemList := Eltseq(ithCol);
        denomElemList := [Denominator(v) : v in colElemList];
        gcd := Lcm(denomElemList);
        val := Valuation(threeAdics ! gcd);
        Append(~scale_list, 3^val);
    end for;
    scale_mat := DiagonalMatrix(Rationals(), scale_list);
    debugLog(matrix);
    debugLog(matrix*scale_mat);
    return matrix*scale_mat;
end function;

// Computes psi(f) for a given modular form
// If the wq matrix is pre-computed, there is an
// optional option for it to be passed in
Psi := function(form : wq := -1) // Pass in wq for memoization
    debugLog("PSI: getting weight");
    weight := Weight(form); // Get the weight
    psi := Parent(form) ! 0;
    FS := BaseExtend(Parent(form), Rationals());
    if wq eq -1 then
        debugLog("PSI: getting wq");
        wq :=  get_Wq(FS, 2);
    end if;
    if (Sprint(BaseRing(form))) ne "Rational Field" then
        _, i1 := BaseExtend(Parent(form), Rationals());
        _, i2 := BaseExtend(FS, BaseRing(form));
        half_weight := Truncate(2^(weight/2)); // Prefactor is 2^(w/2)
        debugLog("PSI: computing psi");
        psi := half_weight * i2(i1(form) * wq); // Compute 2^(w/2) * AtkinLehner(form,2)
    else
        half_weight := Truncate(2^(weight/2));
        psi := half_weight * (form * wq);
    end if;
    return psi;
end function;

// Now we get q2 and q4 via the bases of the weight 2 and 4 modular form spaces
S2 := BaseExtend(ModularForms(2,2), Rationals());
E22 := S2.1;

S4 := BaseExtend(ModularForms(2,4), Rationals());
E4P := S4.1;
EI4 := S4.2;

q2 := 1/2 * E22;
q4 := 1/16*E4P - EI4;             

// The following computes a basis of forms generated by q2 and q4 for a given weight
// All basis elements will have leading coefficient 1 (possible since denominators are all powers of two)
ComputeQ2Q4Basis := function(weight)
    basis := [];
    fourth := Truncate(weight/4); // q4's powers range from 0 to floor(weight / 4)
    half := Truncate(weight/2); // Computing q2's power requires access to 1/2
    debugLog("COMPUTE: Beginning loop");
    for i in [0 .. fourth] do
        fac_1 := 1;
        fac_2 := 1;
        if i ne 0 then // We need these if statements because MAGMA is weird about f^0
            fac_1 := q4^i;
        end if;
        if (half - 2*i) ne 0 then
            fac_2 := q2^(half - 2*i);
        end if;
        debugLog("COMPUTE: Multiplying forms");
        form := fac_1 * fac_2;
        smallestCoef := LeadingCoefficient(qExpansion(form));
        formScaled := (1/smallestCoef) * form;
        basis := Append(basis, formScaled);
    end for;
    return basis;
end function;

c4 := 16*(q2^2 - 3*q4);
c6 := 32*(9*q2*q4-2*q2^3);

ComputeC4C6Basis := function(weight)
    basis := [];
    fourth := Truncate(weight/4); // c4's powers range from 0 to floor(weight / 4)
    sixth := Truncate(weight/6); // Computing c6's power requires access to 1/6
    debugLog("COMPUTE: Beginning loop");
    for i in [0 .. fourth] do
        fac_1 := 1;
        fac_2 := 1;
        if i ne 0 then // We need these if statements because MAGMA is weird about f^0
            fac_1 := c4^i;
        end if;
        if ((weight - 4*i) mod 6 eq 0) and (weight ne 4*i) then
            fac_2 := c6^(Truncate((weight-4*i)/6));
        end if;
        debugLog("COMPUTE: Multiplying forms");
        form := fac_1 * fac_2;
        if Type(form) eq ModFrmElt and Weight(form) eq weight then
            smallestCoef := LeadingCoefficient(qExpansion(form));
            formScaled := (1/smallestCoef) * form;
            basis := Append(basis, formScaled);
        end if;
    end for;
    return basis;
end function;
// This computes the relations matrix for something to be in the kernel of (psis - 1 + phif)
KernelMatrix := function(weight, ring : wq := -1)
    //"Computed M_" cat IntegerToString(weight) cat "(Gamma_0(2)) Space";
    FormSpace := BaseExtend(ModularForms(2,weight), Rationals());
    debugLog("KERMAT: Computing basis");
    basis := ComputeQ2Q4Basis(weight);
    //"Computed Basis";
    dim := #basis;
    //"Computed Dimension";
    half_weight := ring ! Truncate(2^(weight/2));
    //"Computed Half Weight";
    power_weight := ring ! half_weight*half_weight;
    //"Computed Weight";
    //This computation of the dual basis takes the longest amount of time!
    debugLog("KERMAT: Getting WQ");
    if wq eq -1 then
        wq := get_Wq(FormSpace, 2);
    end if;
    debugLog("KERMAT: Computing dual basis");
    dual_basis := [ Psi(f : wq := wq) : f in basis];
    //dual_basis := [];

    //"Computed dual of the basis!";
    CoefRing := PolynomialRing(ring, dim); // Coefficient ring for x1 ... xDim
    //AssignNames(~CoefRing, CreateBasisString(dim));
    eqns := [];

    // We now attempt to get a system of equations using the constraining equation
    // 2^w * (f(tau) - f(2tau) - psi(f)(2tau)) + psi(f)(tau) = 0
    // Expanding f into the basis of q2q4 forms we represent f as 
    // f = sum x_i (q2q4)_i
    // psi(f) = sum x_i (psi(q2q4_i))
    //
    debugLog("KERMAT: Computing equations");
    for i in [0 .. dim-1] do // We need dim equations, which we get from the [0 .. dim - 1] degree q-expansion coefficients
        expr := 0; // We build up the i'th degree expression basis element by basis element
        for n in [1 .. dim] do // Loop over the basis elements
            f_n := basis[n]; //nth basis element
            var := CoefRing . n; // Represents the xi term in the basis expension
            dual_f_n := dual_basis[n];
            // We now get the following coefficients to compute
            ith_coef_f := CoefRing ! Coefficient(f_n, i); // f(tau)_i
            ith_coef_f_dual := CoefRing ! Coefficient(dual_f_n, i); // psi(f)(tau)_i
            i2th_coef_f := 0; // If i is odd, f(2tau)_i is zero
            i2th_coef_f_dual := 0; // similar to above
            if (i mod 2) eq 0 then
                half_i := Truncate(i/2);
                i2th_coef_f := CoefRing ! Coefficient(f_n, half_i); // f(2tau)_i
                i2th_coef_f_dual := CoefRing ! Coefficient(dual_f_n, half_i); // psi(f)(2tau)_i
            end if;
            sub_expr := var*(power_weight*(ith_coef_f
                            - i2th_coef_f
                            - i2th_coef_f_dual)
                            + ith_coef_f_dual); 
            // This represents x_i * (the constraining equation applied to (q2q4)_n at the i'th q expansion coefficient)
            /*if i eq 1 then
                "The " cat IntegerToString(n) cat "th basis element:";
                f_n;
                "The first coef of the " cat IntegerToString(n) cat "th basis element:";
                ith_coef_f;
                "The second coef of the " cat IntegerToString(n) cat "th basis element:";
                i2th_coef_f;
                "The " cat IntegerToString(n) cat "th basis element dual:";
                dual_f_n;
                "The first coef of the " cat IntegerToString(n) cat "th basis element dual:";
                ith_coef_f_dual;
                "The second coef of the " cat IntegerToString(n) cat "th basis element dual:";
                i2th_coef_f_dual;
                "The " cat IntegerToString(n) cat "th expr:";
                sub_expr;
            end if;*/
            expr := expr + sub_expr; // Build the expression up as a sum
        end for;
        eqns := Append(eqns, expr); // Once the expression is built up, add it to the matrix
    end for;
    //"Computed Equations";

    // This now parses the equations into matrix form, as all the terms are linear
    debugLog("KERMAT: Parsing eqns to matrix");
    mat_list := [];
    for eqn in eqns do
        coefs := [];
        for i in [1 .. dim] do
            var := CoefRing.i;
            coef := LeadingCoefficient(Coefficient(eqn, var, 1));
            coefs := Append(coefs, ring ! coef);
        end for;
        mat_list := Append(mat_list, coefs);
    end for;
    mat := Matrix(mat_list);
    return ChangeRing(FactorMatrixRows(mat), ring);
end function;

// This returns the basis for the Kernel at the given weight
// i.e. a matrix s.t. the columns give the coefficients (in the 
// Q2Q4 basis for the given weight) of the elements that span the kernel
Ker := function(weight, ring : wq := -1) 
    debugLog("KER: Computing Kernel Matrix");
    mat := KernelMatrix(weight, ring : wq := wq);
    debugLog("KER: Computing SNF");
    S, P, Q := SmithForm(mat); // The smith form of the relation matrix gives a canonical way to view this kernel
    // To find the kernel, we extract all of the columns of the Q matrix that
    // Correspond to a zero invariant factor in the SNF matrix, which represents
    // The basis matrix of the kernel
    i := 1;
    diagElems := [];
    debugLog("KER: Getting Diag Elems");
    // The following parses the invariant factors into a nice list
    for row in RowSequence(S) do
        diagElem := row[i];
        diagElems := Append(diagElems, row[i]);
        i := i+1;
    end for;
    debugLog("KER: Getting nonzero vecs");
    // Now it searches for the first index where the invariant factor is zero
    first0Index := 1;
    while diagElems[first0Index] ne 0 do
        first0Index := 1 + first0Index;
    end while;
    // We take out common factors to make the basis as simple as possible
    qiScale := ChangeRing(FactorMatrixCols(Q), ring);
    debugLog("KER: Returning submatrix");
    dim := NumberOfRows(qiScale);
    // We extract the columns corresponding to zero invariant factors
    submat := Submatrix(qiScale, 1, first0Index, dim, (dim - first0Index+1));
    // We take the column-echelon form of the basis matrix which 
    // ensures that the basis returned is linearly independent.
    submatT := Transpose(EchelonForm(Transpose(submat)));
    submat := EnsureNoColDivByThree(submatT); //Its nicer to work over Rationals and just forbid division by 3.
    // We get the basis that submat is w.r.t
    basis := ComputeQ2Q4Basis(weight);
    if Sprint(BaseRing(basis[1])) ne Sprint(ring) then
        RFS, phi := BaseExtend(Parent(basis[1]), ring);
        basis := [phi(f) : f in basis];
    end if;
    kernel_basis := [];
    const_terms := [];
    // We now combine the kernel basis with the canonical basis to get 
    // the basis of forms for the kernel
    for i in [1 .. NumberOfColumns(submat)] do
        ithCol := ColumnSubmatrix(submat, i, 1);
        form := (Parent(basis[1]) ! 0); 
        const_term := 0;
        for j in [1 .. NumberOfRows(ithCol)] do
            form := form + basis[j]*ithCol[j][1];
            const_term := const_term + ithCol[j][1];
        end for;
        // There's a nice congruence that all of the forms in 
        // the q2q4 basis have their non-constant terms divisible by 4
        // so if the constant term of the form is divisible by 4
        // then the whole modular form is divisible by 4
        if Numerator(const_term) mod 4 eq 0 then
            form := 1/4 * form;
        end if;
        Append(~kernel_basis, form);
        Append(~const_terms, const_term);
    end for;
    // We return the matrix basis as well as the basis of modular forms
    return kernel_basis;
end function;

IsModular := function(f : wq := -1)
    weight := Weight(f);
    fh_almost := Psi(f : wq := wq); // No factor of 2^-weight cuz converting to rationals is annoying
    for i in [1 .. Precision(Parent(f))/2] do
        if 2^weight*Coefficient(f, i) ne Coefficient(fh_almost, 2*i) then
            return false;
        end if;
    end for;
    return true;
end function;

HomotopyGroupOrder := function(n)
    if n mod 8 in [0,1] then
        return 2;
    elif n mod 8 in [2,4,5,6] then
        return 0;
    else
        return Denominator(BernoulliNumber(2*n)/4*n);
    end if;
end function;
//c4 = 16*(q2^2 - 3 q4) = E4!!!
//c6 = -64q2^3 +9*32*q2*q4 = 32*(9*q2*q4-2*q2^3) = E6!!!

PsiDP1Inv := function(f)
    scale := 1/(2^(Weight(f))-1);           
    return scale * (Psi(f)-f);
end function;

TwistMult := function(f,g)
    if Type(f) ne ModFrmElt and Type(g) ne ModFrmElt then
        return f*g;
    elif Type(f) ne ModFrmElt then
        return 1/2*(f*g+PsiDP1Inv(f*g+Psi(g)*f));
    elif Type(g) ne ModFrmElt then
        return 1/2* (f*g+PsiDP1Inv(Psi(f)*g+f*g));
    else
        return 1/2*(f*g + PsiDP1Inv(Psi(f)*g+Psi(g)*f));
    end if;
end function;

InKer := function(f)
    return IsModular(Psi(f)+f);
end function;